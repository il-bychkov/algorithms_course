# Лекция 1.  Массивы, вычислительная сложность, тестирование.

В большинстве случаев объем данных, обрабатываемых алгоритмам, достаточно велик, что не позволяет ограничиваться только использованием переменных (если конечно вы не решаете только задачи типа “A+B Problem”).

В таких случаях на помощь приходят разнообразные структуры данных.

Структура данных — это контейнер, который хранит данные и обеспечивает работу с ними в соответствии с определенными правилами.

Первая и самая простая структура данных (часто ее даже не относят к структурам данных), которую мы рассмотрим, называется массив.

Массив - это структура данных, для которой характерно:

1. Хранение элементов одного типа 
2. Размещение элементов последовательно в памяти
3. Единое имя для всех элементов

Полезно думать о массиве как об определенном наборе переменных одного типа.

**Имя массива** указывает на адрес в памяти его самого первого элемента. Доступ к элементам массива осуществляется с помощью **индексов** или **смещений**. Самый первый элемент имеет **нулевое смещение** относительно адреса массива в памяти.

![array_structure](./images/array_structure.png)

**Изображение 1.0 - Структура данных масси и её устройство**

**Источник: -**

Пример работы с массивами

![array_example](./images/array_example.png)

**Изображение 1.1 - Пример работы с массивом**

**Источник: **

Алгоритмы для работы с массивами:

- вставка/удаление/замена элементов
- поиск элемента
- поиск элемента с заданными свойствами
- сортировка массива

### Чтение/запись элемента

**Входные данные:** массив, позиция для чтения/вставки
**Результат:** элемент на запрашиваемой позиции или измененный массив

![array_read_write](./images/array_read_write.png)

**Изображение 1.2 - Вставка элемента в массив**

**Источник: **

### Вставка элемента

**Входные данные:** массив, элемент для вставки, позиция для вставки
**Результат:** массив с вставленным элементов

![array_insert](./images/array_insert.png)

**Изображение 1.2 - Вставка элемента в массив**

**Источник: **

### Удаление элемента

Удаление элемента

Входные данные: массив, позиция удаляемого элемента
Результат: массив без удаленного элемента

![array_delete](./images/array_delete.png)

**Изображение 1.3 - Удаление элемента из массива**

**Источник: **


### Поиск вхождения элемента (linear search)

Входные данные: массив, искомый элемент
Результат: индекс искомого элемента, если он есть в массиве
Сложность в худшем случае: O(n)

![array_search](./images/array_search.png)

**Изображение 1.4 - Поиск вхождения элемента в массив**

**Источник: **

### Поиск элемента с заданными свойствами

Входные данные: массив, критерии поиска
Результат: индекс искомого элемента, если он есть в массиве
Сложность в худшем случае: O(n)

![array_search_special](./images/array_search_special.png)

**Изображение 1.4 - Поиск элемента с заданными свойствами в массиве**

**Источник: **

### Многомерные массивы 

![arrays_ndim](array_ndim.png)

**Изображение 1.4 - Пример многомерного массива**

**Источник: **

![arrays_ndim2](array_ndim2.png)

**Изображение 1.4 - Пример многомерного массива 2**

**Источник: https://overiq.com/c-programming-101/array-of-pointers-to-strings-in-c/ **


Row-major и column-major массивы

![[array_rowcolumn.png]]

**Изображение 1.4 - Row-major и column-major огранизация массива**

**Источник: https://craftofcoding.wordpress.com/2017/02/03/column-major-vs-row-major-arrays-does-it-matter/**

### Динамические массивы

Под динамическими массивами обычно имеют ввиду:

массивы, размер которых не известен заранее, память для них выделяется на этапе работы программы

структуры данных, имеющих внутри массивы и реализующие специальную логику по автоматическому увеличению их размера при необходимости

![array_dynamic](array_dynamic.png)

**Изображение 1.4 - Пример многомерного массива 2**

### Сложность операций в массивах

![[array_complexity_table.png]]

### Преимущества и недостатки массивов

![[array_pros_cons.png]]